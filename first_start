#include <iostream>
#include <cmath>
#include <string>
#include <array>
#include <vector>
#include <algorithm>
#include <random>
#include <ctime>
#include <iterator>
#include <utility>
#include <typeinfo>
#include <chrono>

namespace mut
{
    constexpr double mutation_rate{ 0.02 }; //in percent%
    constexpr int genotype_length{ 100 };
    constexpr double max_fitness{ 0.1 }; // the maximum fitness advantage if genotype matches target sequence
    constexpr double change{max_fitness / genotype_length};
    constexpr char ideal{ 'A' };

}



double generate_random(const double min, const double max)     // double RNG
{
    auto seed = std::chrono::high_resolution_clock::now().time_since_epoch().count();
    std::mt19937 mersenne{ static_cast<std::mt19937::result_type>(seed) };

    std::uniform_real_distribution<double> num{ min, max };

    double prob = num(mersenne);
    return prob;
}

int generate_random_int(const int min, const int max)          // integer RNG
{
    auto seed = std::chrono::high_resolution_clock::now().time_since_epoch().count();
    std::mt19937 mersenne{ static_cast<std::mt19937::result_type>(seed) };

    std::uniform_int_distribution<> num{ min, max };

    int prob = num(mersenne);
    return prob;
}

class individual
{
    std::string m_genotype;
    double m_fitness;
    char m_allele{ 'x' };

public:
    void setindividual(std::string genotype, char allele, double fitness = 1.0)
    {
        m_genotype = genotype;
        m_allele = allele;
        m_fitness = fitness;
    }
    std::string get_genotype()
    {
        return m_genotype;
    }

    char get_allele()
    {
        return m_allele;
    }


    double get_fitness()
    {
        return m_fitness;
    }

    void determine_fitness()            // this has to be called at the beginning of every generation to determine fitness
    {

        m_fitness = 1.0;
        for (unsigned int i = 0; i < m_genotype.size(); ++i)
        {
            if (m_genotype[i] == mut::ideal)
                m_fitness += mut::change;
            else 
                m_fitness -= mut::change;
        }
    }

        
    void mutate()      //every generation call this function to mutate each nucleotide at a rate of % mutation rate 
    {
        for (unsigned int count = 0; count < m_genotype.length(); ++ count)
        {
            double chance = generate_random(0.0, 100.0);
            if (chance < mut::mutation_rate)
            {
                int new_type = generate_random_int(1, 3);
                char a = m_genotype[count];
                switch (a)
                {
                case 'A':
                    switch (new_type)
                    {
                    case 1:
                        m_genotype[count] = 'U';
                        break;
                    case 2:
                        m_genotype[count] = 'G';
                        break;
                    case 3:
                        m_genotype[count] = 'C';
                        break;
                    }
                    break;

                case 'G':
                    switch (new_type)
                    {
                    case 1:
                        m_genotype[count] = 'U';
                        break;
                    case 2:
                        m_genotype[count] = 'C';
                        break;
                    case 3:
                        m_genotype[count] = 'A';
                        break;
                    }
                    break;

                case 'C':
                    switch (new_type)
                    {
                    case 1:
                        m_genotype[count] = 'A';
                        break;
                    case 2:
                        m_genotype[count] = 'U';
                        break;
                    case 3:
                        m_genotype[count] = 'G';
                        break;
                    }
                    break;

                case 'U':
                    switch (new_type)
                    {
                    case 1:
                        m_genotype[count] = 'A';
                        break;
                    case 2:
                        m_genotype[count] = 'C';
                        break;
                    case 3:
                        m_genotype[count] = 'G';
                        break;
                    }
                    break;

                default:
                    m_genotype[count] = 'Z';
                    break;
                }

            }
        }
    }
    
};



class population
{
    std::vector<individual> m_total;
    
public:

    void set_population(std::vector<individual> total)
    {
        m_total = total;
    }

    std::vector<individual> get_population()
    {
        return m_total;
    }



    void process(int generations)    //selective process
    {
        const int gens = generations;
        int allele_counter{1};  // use previous generation "p" and "q" count to ensure death of a particular allele iterates once only
        while (generations > 0)
        {
            for (unsigned int i = 0; i < m_total.size(); ++i)
            {
                m_total[i].mutate();
                m_total[i].determine_fitness();
            }

            double total_fitness{};
            for (individual i : m_total)
            {
                total_fitness += i.get_fitness();
            }
            double average_fitness = total_fitness / m_total.size();              // calculate an average fitness of all members of population

            int sizer = m_total.size();
            for (int count = 0; count < sizer; ++count)
            {
                double replication = ((m_total[count].get_fitness() / average_fitness) * 50);      //individuals more likely to replicate if fitness is above average
                double prob = generate_random(0.0, 100.0);
                if (replication >= prob)
                {
                    m_total.push_back(m_total[count]);
                    ++sizer;
                }
                else
                {
                    std::swap(m_total[count], m_total.back());
                    m_total.pop_back();
                    --sizer;
                }
            }
            if (m_total.size() == 0)
            {
                std::cout << "All sequences have died!! \n";
                generations = 0;
            }

            --generations;
            if (generations % 50 == 0)
                std::cout << gens - generations << " generations compeleted out of " << gens << " total.\n";
            
            if (allele_counter == 0)
            {
                std::cout << "              ALLELE HAS DIED WITH " << generations << " GENERATIONS LEFT " <<  '\n';
                allele_counter = -100;
            }


            if (allele_counter > 0)
            {
                
                int p_count{};
                int q_count{};
                for (individual i : m_total)
                {

                    if (i.get_allele() == 'p')
                        ++p_count;
                    else
                        ++q_count;
                    
                }
                if (p_count >= q_count)
                {
                    allele_counter = q_count;
                    if (allele_counter == 0)
                    {
                        std::cout << "              ALLELE #1 (p) HAS DIED WITH " << generations << " GENERATIONS LEFT " << '\n';
                        allele_counter = -100;
                    }

                }

                else
                {
                    allele_counter = p_count;
                    if (allele_counter == 0)
                    {
                        std::cout << "              ALLELE #2 (q) HAS DIED WITH " << generations << " GENERATIONS LEFT " << '\n';
                        allele_counter = -100;
                    }

                }

                
            }
        }

    }
};





char generate_base()                  // generate a random nucleotide char which will be concantenated to string
{


    int nucleotide = generate_random_int(1, 4);

    switch (nucleotide)
    {
    case 1: 
        return 'A';
    case 2: 
        return 'G';
    case(3): 
        return 'C';
    case(4): 
        return 'U';
    default:
        return 'F';
    }
}



std::string sequence_generation(const int length)
{
    std::string sequence;
    sequence.resize(length, '+');
    for (unsigned int i = 0; i < sequence.size(); ++i)
    {
        sequence[i] = generate_base();
    }
    return sequence;
}



void two_alleles(int pop_size, int generations, int num_alleles)
{
    population test;
    individual ind;
    ind.setindividual(sequence_generation(mut::genotype_length), 'p');
    ind.determine_fitness();
    double initial_fitness1 = ind.get_fitness();

    std::cout << "Primordial Genotype allele #1 (p): " << ind.get_genotype() << '\n';
    std::cout << "Primordial Fitness allele #1 (p): " << ind.get_fitness() << '\n';
    std::cout << "Primordial Sequence Identity allele #1 (p): " << (ind.get_fitness() - (1 - mut::max_fitness)) / (mut::change * 2) << " out of " << mut::genotype_length << '\n' << '\n';

    std::vector<individual> array;

    for (int i = 0; i < pop_size / 2; ++i)
    {
        array.push_back(ind);
    }

    individual ind2;
    ind2.setindividual(sequence_generation(mut::genotype_length), 'q');
    ind2.determine_fitness();
    double initial_fitness2 = ind2.get_fitness();

    std::cout << "Primordial Genotype allele #2 (q): " << ind2.get_genotype() << '\n';
    std::cout << "Primordial Fitness allele #2 (q): " << ind2.get_fitness() << '\n';
    std::cout << "Primordial Sequence Identity allele #2 (q): " << (ind2.get_fitness() - (1 - mut::max_fitness)) / (mut::change * 2) << " out of " << mut::genotype_length << '\n' << '\n';

    for (int i = pop_size / 2; i < pop_size; ++i)
    {
        array.push_back(ind2);
    }
    test.set_population(array);


    test.process(generations);

    array = test.get_population();

    double average_fitness{};
    int total_alive{};
    int p_count{};
    int q_count{};
    for (individual i : array)
    {
        std::cout << i.get_genotype() << "       " << i.get_allele() << '\n';
        if (i.get_allele() == 'p')
            ++p_count;
        else
            ++q_count;

        average_fitness += i.get_fitness();
        ++total_alive;

    }

    average_fitness = average_fitness / array.size();
    std::cout << '\n' << total_alive << " sequences survived." << '\n';
    std::cout << "Total primordial genotype #1 (allele p): " << p_count << '\n' << "Total primordial genotype #2 (allele q): " << q_count << '\n' << '\n';
    std::cout << "The average fitness after " << generations << " generations was: " << average_fitness << '\n';
    std::cout << "This was " << average_fitness - initial_fitness1 << " greater than the primordial genotype #1 and " << average_fitness - initial_fitness2
        << " greater than primordial genotype #2. \nThe mutation rate was: " << mut::mutation_rate << "%";
    std::cout << " per nucleotide per generation. " << '\n';
    std::cout << "Average sequence identity: " << (average_fitness - (1 - mut::max_fitness)) / (mut::change * 2) << " out of " << mut::genotype_length << '\n';


}

int main()
{

    
    std::cout << "What is population size? ";
    int pop_size{};
    std::cin >> pop_size;

    std::cout << "How many generations? ";
    int generations{};
    std::cin >> generations;

    int num_alleles = 2;
    
    two_alleles(pop_size, generations, num_alleles);

    return 0;

    
}
